// // import { AssistantAgent, UserProxyAgent } from "autogen";
// import dotenv from "dotenv";

// // Load environment variables
// dotenv.config();

// const OPENAI_API_KEY = process.env.GPT_API_KEY;

// if (!OPENAI_API_KEY) {
//   throw new Error("GPT_API_KEY is not set in environment variables");
// }

// // LLM configuration for AutoGen agents
// const llmConfig = {
//   model: "gpt-3.5-turbo",
//   api_key: OPENAI_API_KEY,
//   timeout: 60,
//   max_tokens: 1000,
// };

// // Define allowed Solana RPC actions
// const allowedActions = [
//   "getBalance",
//   "getBlock",
//   "getBlockHeight",
//   "getBlockProduction",
//   "getEpochInfo",
//   "getEpochSchedule",
//   "getFirstAvailableBlock",
//   "getGenesisHash",
//   "getHealth",
//   "getIdentity",
//   "getInflationRate",
//   "getLatestBlockhash",
//   "getLeaderSchedule",
//   "getMaxRetransmitSlot",
//   "getMaxShredInsertSlot",
//   "getMinimumBalanceForRentExemption",
//   "getSlot",
//   "getSupply",
//   "getTokenAccountBalance",
//   "getTransactionCount",
//   "getVersion",
//   "getVoteAccounts",
// ];

// // Solana RPC Query Processor Agent
// const queryProcessorAgent = new AssistantAgent({
//   name: "QueryProcessor",
//   llmConfig,
//   systemMessage: `
//     You are a Solana blockchain expert assistant. Your role is to process a user's natural language query and identify the correct Solana RPC method they intend to call. The allowed RPC methods are: ${allowedActions.join(
//       ", "
//     )}.

//     Follow these guidelines:
//     1. Analyze the user's query to determine the intended RPC method.
//     2. If the query requires an address (e.g., for getBalance or getTokenAccountBalance), extract the address.
//     3. If the query requires a block number (e.g., for getBlock), extract the block number.
//     4. If the query requires a data size (e.g., for getMinimumBalanceForRentExemption), extract it.
//     5. Respond ONLY in valid JSON format with the following structure:
//        {
//          "action": "ACTION_NAME",
//          "address": "OPTIONAL_IF_NEEDED",
//          "blockNumber": "OPTIONAL_IF_NEEDED",
//          "dataSize": "OPTIONAL_IF_NEEDED"
//        }
//     6. Omit optional fields (address, blockNumber, dataSize) if they are not needed.
//     7. If the query is unclear or unrelated to Solana RPC methods, return:
//        {
//          "action": "unknown"
//        }

//     Ensure the response is precise and adheres to the specified JSON format.
//   `,
// });

// // Parameter Extraction Agent
// const parameterExtractionAgent = new AssistantAgent({
//   name: "ParameterExtractor",
//   llmConfig,
//   systemMessage: `
//     You assist the QueryProcessor by extracting specific parameters from the user's query, such as Solana addresses, block numbers, or data sizes. Your role is to ensure that the extracted parameters are valid and relevant to the identified RPC method.

//     Guidelines:
//     1. If the RPC method requires an address (e.g., getBalance, getTokenAccountBalance), validate and extract the address.
//     2. If the RPC method requires a block number (e.g., getBlock), extract and validate the block number.
//     3. If the RPC method requires a data size (e.g., getMinimumBalanceForRentExemption), extract and validate the data size.
//     4. Return the extracted parameters in JSON format, omitting fields that are not applicable.
//     5. If no parameters are needed or the query is invalid, return an empty object or flag the query as unclear.
//   `,
// });

// // Response Validation Agent
// const responseValidationAgent = new AssistantAgent({
//   name: "ResponseValidator",
//   llmConfig,
//   systemMessage: `
//     You validate the JSON response generated by the QueryProcessor and ParameterExtractor to ensure it complies with the required format and Solana RPC method constraints.

//     Guidelines:
//     1. Verify that the "action" field contains a valid RPC method from: ${allowedActions.join(
//       ", "
//     )}.
//     2. Ensure optional fields (address, blockNumber, dataSize) are only included when required by the RPC method.
//     3. Check that the response is in valid JSON format.
//     4. If the response is invalid or the action is "unknown" when it shouldn't be, flag it for correction.
//     5. Return a validated or corrected JSON response.
//   `,
// });

// // User Context Agent
// const userContextAgent = new AssistantAgent({
//   name: "UserContextManager",
//   llmConfig,
//   systemMessage: `
//     You manage user-specific data and context to assist in processing Solana RPC queries. Store and recall user preferences or frequently used addresses to improve query processing accuracy.

//     Guidelines:
//     1. Store user-provided addresses or query patterns if specified.
//     2. Use context to suggest parameters when the query is ambiguous.
//     3. Do not override explicit parameters provided in the current query.
//   `,
// });

// // User Proxy Agent
// const userProxy = new UserProxyAgent({
//   name: "UserProxy",
//   llmConfig,
//   systemMessage: `
//     You facilitate communication between the user and the specialized Solana agents (QueryProcessor, ParameterExtractor, ResponseValidator, UserContextManager). Your role is to route the user's query to the appropriate agents and compile the final JSON response.
//   `,
//   codeExecutionConfig: { useDocker: false },
// });


// // app.post("/solana-rpc", async (req: Request, res: Response) => {
// //   const { query } = req.body;

// //   if (!query || typeof query !== "string") {
// //     return res.status(400).json({ error: "Invalid or missing query" });
// //   }

// //   try {
// //     // Simulate agent interaction (AutoGen handles internal communication)
// //     const response = await userProxy.initiateChat({
// //       recipient: queryProcessorAgent,
// //       message: `Process this Solana RPC query: ${query}`,
// //     });

// //     // Extract the final JSON response from the agent interaction
// //     // Note: This is a simplified representation; actual AutoGen response handling may vary
// //     const jsonResponse = JSON.parse(response.lastMessage.content);

// //     // Validate the response using the ResponseValidator agent
// //     const validationResult = await responseValidationAgent.receiveMessage({
// //       sender: queryProcessorAgent,
// //       message: JSON.stringify(jsonResponse),
// //     });

// //     const finalResponse = JSON.parse(validationResult.content);

// //     res.json(finalResponse);
// //   } catch (error) {
// //     console.error("Error processing query:", error);
// //     res.status(500).json({ action: "unknown", error: "Internal server error" });
// //   }
// // });


// export async function parseUserQuery(query: string): Promise<any> {
//   try {
//     // Initiate agent communication via UserProxy
//     const response = await userProxy.initiateChat({
//       recipient: queryProcessorAgent,
//       message: `Process this Solana RPC query: ${query}`,
//     });

//     // Extract the JSON response from the QueryProcessor agent
//     const jsonResponse = JSON.parse(response.lastMessage.content);

//     // Validate the response using the ResponseValidator agent
//     const validationResult = await responseValidationAgent.receiveMessage({
//       sender: queryProcessorAgent,
//       message: JSON.stringify(jsonResponse),
//     });

//     // Return the validated JSON response
//     return JSON.parse(validationResult.content);
//   } catch (error) {
//     console.error("Error processing query:", error);
//     return { action: "unknown", error: "Internal processing error" };
//   }
// }